/* * Copyright 2013 Vlad V. Ungureanu <ungureanuvladvictor@gmail.com>. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this Github repository and wiki except in * compliance with the License. You may obtain a copy of the License at * *       http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package com.vvu.beagledroid;import java.io.BufferedReader;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.Iterator;import java.util.List;import android.app.Activity;import android.app.DownloadManager;import android.content.Context;import android.hardware.usb.UsbDevice;import android.hardware.usb.UsbDeviceConnection;import android.hardware.usb.UsbEndpoint;import android.hardware.usb.UsbInterface;import android.hardware.usb.UsbManager;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.os.SystemClock;import android.util.Log;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.CheckBox;import android.widget.Spinner;import android.widget.Toast;public class MainActivity extends Activity {		static final String TAG = "BBB";	String downloadedFile;	static final byte[] AndroidMac = {(byte)0x9A, (byte)0x1F, (byte)0x85, (byte)0x1C, (byte)0x3D, (byte)0x0E};	static final byte[] BBBIP = {(byte)0xC0, (byte)0xA8, (byte)0x01, (byte)0x03};	static final byte[] AndroidIP = {(byte)0xC0, (byte)0xA8, (byte)0x01, (byte)0x09};	static final byte[] serverName = {(byte)'A', (byte)'n', (byte)'d', (byte)'r', (byte)'o', (byte)'i', (byte)'d', (byte)'\0'};	static final byte[] fileName = {(byte)'M', (byte)'L', (byte)'O', (byte)'\0'};	static final byte[] END = {(byte)'F', (byte)'I', (byte)'N'};	static final byte protocolUDP = (byte) 0x11;	static final short ethARP = (short) 0x0806;	static final short ethIP = (short) 0x0800;	static final short BOOTPS = (short) 67;	static final short BOOTPC = (short) 68;	static final short romxID = 1;	static final int RNDISSize = 44;	static final int ETHSize = 14;	static final int IPSize = 20;	static final int ARPSize = 28;	static final int UDPSize = 8;	static final int BOOTPSize = 300;	static final int TFTPSize = 4;	long soFar = 0;	@Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);                Button flasher = (Button) findViewById(R.id.button1);        Button downloader = (Button) findViewById(R.id.button3);    	        final Spinner spinner1 = (Spinner) findViewById(R.id.spinner1);    	spinner1.setAdapter(setupSpinner());            	flasher.setOnClickListener(new OnClickListener() {			public void onClick(View v) {				new Thread(new Runnable() {					public void run() {						File file = new File(Environment.getExternalStorageDirectory().getPath(), "/BBB/flash.img.xz" );						if(!file.exists() && downloadedFile == null){							runOnUiThread(new Runnable() {							    public void run() {									Context context = getApplicationContext();									CharSequence text = "Please download an image!";									int duration = Toast.LENGTH_LONG;									Toast toast = Toast.makeText(context, text, duration);									toast.show();							    }							});							return;						}						else if(file.exists())							downloadedFile = "flash.img.xz";						runRom();						runOnUiThread(new Runnable() {						    public void run() {								Context context = getApplicationContext();								CharSequence text = "MLO Started!";								int duration = Toast.LENGTH_LONG;								Toast toast = Toast.makeText(context, text, duration);								toast.show();						    }						});						SystemClock.sleep(2000);						UsbDevice myDev = null;						UsbManager manager = (UsbManager) getSystemService(Context.USB_SERVICE);						HashMap<String, UsbDevice> deviceList = manager.getDeviceList();						Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();						while (deviceIterator.hasNext()) {							UsbDevice dev = deviceIterator.next();							if (dev.getProductId() == 42146 && dev.getVendorId() == 1317)								myDev = dev;						}						if (myDev == null) {							Log.d(TAG, "nothing!");							return;						}						while (!manager.hasPermission(myDev)){}												runUBoot();						runOnUiThread(new Runnable() {						    public void run() {								Context context = getApplicationContext();								CharSequence text = "U-Boot Started";								int duration = Toast.LENGTH_LONG;								Toast toast = Toast.makeText(context, text, duration);								toast.show();						    }						});						SystemClock.sleep(5000);						runFIT();						runOnUiThread(new Runnable() {						    public void run() {								Context context = getApplicationContext();								CharSequence text = "Booting kernel!";								int duration = Toast.LENGTH_LONG;								Toast toast = Toast.makeText(context, text, duration);								toast.show();						    }						});						SystemClock.sleep(21000);						deviceList = manager.getDeviceList();						deviceIterator = deviceList.values().iterator();						while (deviceIterator.hasNext()) {							UsbDevice dev = deviceIterator.next();							if (dev.getProductId() == 42151 && dev.getVendorId() == 1317)								myDev = dev;						}						while (!manager.hasPermission(myDev)){}						runOnUiThread(new Runnable() {						    public void run() {								Context context = getApplicationContext();								CharSequence text = "Starting to send image!";								int duration = Toast.LENGTH_LONG;								Toast toast = Toast.makeText(context, text, duration);								toast.show();						    }						});						runWrite(downloadedFile);					}				}).start();			}		});        downloader.setOnClickListener(new OnClickListener() {					public void onClick(View v) {				new Thread(new Runnable() {					public void run() {						try {							downloadImage(spinner1.getSelectedItem().toString());						} catch (Exception e) {							e.printStackTrace();						}					}				}).start();			}		});	}	@Override    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }		public void runRom() {		new Thread(new Runnable() {			public void run() {				byte[] buffer = new byte[450];				UsbDevice myDev = null;				UsbManager manager = (UsbManager) getSystemService(Context.USB_SERVICE);				HashMap<String, UsbDevice> deviceList = manager.getDeviceList();				Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();				while (deviceIterator.hasNext()) {					UsbDevice dev = deviceIterator.next();					if (dev.getProductId() == 24897 && dev.getVendorId() == 1105)						myDev = dev;				}				if (myDev == null) {					Log.d(TAG, "nothing!");					return;				}				UsbInterface intf = myDev.getInterface(1);				UsbEndpoint readEP = intf.getEndpoint(0);				UsbEndpoint writeEP = intf.getEndpoint(1);				UsbDeviceConnection connection = null;				while (!manager.hasPermission(myDev)){}				if (manager.hasPermission(myDev)) {					connection = manager.openDevice(myDev);				} 				else Log.d(TAG, "no permissions");				connection.claimInterface(intf, true);				int tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				byte[] BBBMac = Arrays.copyOfRange(Arrays.copyOfRange(buffer, 						RNDISSize, RNDISSize + ETHSize),6,12);				BOOTP bootpAnswer = new BOOTP(romxID, BBBIP, AndroidIP, AndroidIP, BBBMac, serverName, fileName);				UDP udpAnswer = new UDP(BOOTPS, BOOTPC, (short)BOOTPSize);				IPv4 ipAnswer = new IPv4((short) (udpAnswer.getLen() + (short)IPSize), (short)0, protocolUDP, AndroidIP, BBBIP);				Ether2 etherAnswer = new Ether2(BBBMac, AndroidMac, ethIP);				RNDIS rndisAnswer = new RNDIS(ETHSize + IPSize + UDPSize + BOOTPSize);				ByteMaker send = new ByteMaker();				byte[] output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), ipAnswer.getByteArray(), udpAnswer.getByteArray(), bootpAnswer.getByteArray());				tmp = connection.bulkTransfer(writeEP, output, output.length, 10);				tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				ARP arpAnswer = new ARP((short)2, AndroidMac, AndroidIP, BBBMac, BBBIP);				etherAnswer.setH_proto(ethARP);				rndisAnswer.updateRNDIS(ETHSize+ARPSize);								output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), arpAnswer.getByteArray());				tmp = connection.bulkTransfer(writeEP, output, output.length, 10);				tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);								try {					File myFile = new File(Environment.getExternalStorageDirectory().getPath() + "/BBB/u-boot-spl.bin");					FileInputStream fIn = new FileInputStream(myFile);					byte[] temporary = new byte[512];					int block = 1;					int count = fIn.read(temporary, 0, 512);					while(count != -1) {						TFTP tftpAnswer = new TFTP((short)3, (short)block);						udpAnswer = new UDP((short)0x45, (short)0x4D2, (short) (TFTPSize + count));						ipAnswer = new IPv4((short) (udpAnswer.getLen() + (short)IPSize), (short)0, protocolUDP, AndroidIP, BBBIP);						etherAnswer = new Ether2(BBBMac, AndroidMac, ethIP);						rndisAnswer = new RNDIS(ETHSize + IPSize + UDPSize + TFTPSize + count);						tftpAnswer.setBlk_numer((short)block);												output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), ipAnswer.getByteArray(), udpAnswer.getByteArray(), tftpAnswer.getByteArray(), temporary);												byte[] result = send.stripSize(output, RNDISSize + ETHSize + IPSize + UDPSize + TFTPSize + count);						tmp = connection.bulkTransfer(writeEP, result, result.length, 200);						buffer = new byte[450];						tmp = connection.bulkTransfer(readEP, buffer, 450, 200);						temporary = new byte[512];						block++;						count = fIn.read(temporary, 0, 512);					}					fIn.close();				} catch (Exception e) {					Log.d(TAG, e.getMessage());					return;				}			}		}).start();	}	public void runUBoot() {		new Thread(new Runnable() {			public void run() {				byte[] buffer = new byte[450];				UsbDevice myDev = null;				UsbManager manager = (UsbManager) getSystemService(Context.USB_SERVICE);				HashMap<String, UsbDevice> deviceList = manager.getDeviceList();				Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();				while (deviceIterator.hasNext()) {					UsbDevice dev = deviceIterator.next();					if (dev.getProductId() == 42146 && dev.getVendorId() == 1317)						myDev = dev;				}				if (myDev == null) {					Log.d(TAG, "nothing!");					return;				}				UsbInterface intf = myDev.getInterface(1);				UsbEndpoint readEP = intf.getEndpoint(0);				UsbEndpoint writeEP = intf.getEndpoint(1);				UsbDeviceConnection connection = null;				while (!manager.hasPermission(myDev)){}				if (manager.hasPermission(myDev)) {					connection = manager.openDevice(myDev);				} 				else Log.d(TAG, "no permissions");				connection.claimInterface(intf, true);				int tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				byte[] BBBMac = Arrays.copyOfRange(Arrays.copyOfRange(buffer, 						RNDISSize, RNDISSize + ETHSize),6,12);				byte[] bootp = Arrays.copyOfRange(buffer, RNDISSize + ETHSize + 												IPSize + UDPSize, RNDISSize + ETHSize + 												IPSize + UDPSize + BOOTPSize);				byte[] xid = Arrays.copyOfRange(bootp, 4, 8);				BOOTP bootpAnswer = new BOOTP(ByteBuffer.wrap(xid).getInt(), BBBIP, AndroidIP, 												AndroidIP, BBBMac, serverName, fileName);				UDP udpAnswer = new UDP(BOOTPS, BOOTPC, (short)BOOTPSize);				IPv4 ipAnswer = new IPv4((short) (udpAnswer.getLen() + (short)IPSize), (short)0, 													protocolUDP, AndroidIP, BBBIP);				Ether2 etherAnswer = new Ether2(BBBMac, AndroidMac, ethIP);				RNDIS rndisAnswer = new RNDIS(ETHSize + IPSize + UDPSize + BOOTPSize);				ByteMaker send = new ByteMaker();				byte[] output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), 												ipAnswer.getByteArray(), udpAnswer.getByteArray(), 												bootpAnswer.getByteArray());				tmp = connection.bulkTransfer(writeEP, output, output.length, 10);				tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				ARP arpAnswer = new ARP((short)2, AndroidMac, AndroidIP, BBBMac, BBBIP);				etherAnswer.setH_proto(ethARP);				rndisAnswer.updateRNDIS(ETHSize+ARPSize);								output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), arpAnswer.getByteArray());				tmp = connection.bulkTransfer(writeEP, output, output.length, 10);				tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				byte[] udp = Arrays.copyOfRange(buffer, RNDISSize +ETHSize + IPSize, RNDISSize +ETHSize + IPSize + UDPSize);				byte[] dstPort = Arrays.copyOfRange(udp, 0, 2);				byte[] srcPort = Arrays.copyOfRange(udp, 2, 4);				short sPort = ByteBuffer.wrap(srcPort).getShort();				short dPort = ByteBuffer.wrap(dstPort).getShort();								try {					File myFile = new File(Environment.getExternalStorageDirectory().getPath() + "/BBB/u-boot.img");					FileInputStream fIn = new FileInputStream(myFile);					byte[] temporary = new byte[512];					int block = 1;					int count = fIn.read(temporary, 0, 512);					while(count != -1) {						TFTP tftpAnswer = new TFTP((short)3, (short)block);						udpAnswer = new UDP(sPort, dPort, (short) (TFTPSize + count));						ipAnswer = new IPv4((short) (udpAnswer.getLen() + (short)IPSize), (short)0, protocolUDP, AndroidIP, BBBIP);						etherAnswer = new Ether2(BBBMac, AndroidMac, ethIP);						rndisAnswer = new RNDIS(ETHSize + IPSize + UDPSize + TFTPSize + count);						tftpAnswer.setBlk_numer((short)block);												output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), 												ipAnswer.getByteArray(), udpAnswer.getByteArray(), 												tftpAnswer.getByteArray(), temporary);												byte[] result = send.stripSize(output, RNDISSize + ETHSize + IPSize + UDPSize + TFTPSize + count);						tmp = connection.bulkTransfer(writeEP, result, result.length, 200);						buffer = new byte[450];						tmp = connection.bulkTransfer(readEP, buffer, 450, 200);						temporary = new byte[512];						block++;						count = fIn.read(temporary, 0, 512);					}					fIn.close();				} catch (Exception e) {					Log.d(TAG, e.getMessage());					return;				}			}		}).start();	}	public void runFIT() {		new Thread(new Runnable() {			public void run() {				byte[] buffer = new byte[450];				UsbDevice myDev = null;				UsbManager manager = (UsbManager) getSystemService(Context.USB_SERVICE);				HashMap<String, UsbDevice> deviceList = manager.getDeviceList();				Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();				while (deviceIterator.hasNext()) {					UsbDevice dev = deviceIterator.next();					if (dev.getProductId() == 42146 && dev.getVendorId() == 1317)						myDev = dev;				}				if (myDev == null) {					Log.d(TAG, "nothing!");					return;				}				UsbInterface intf = myDev.getInterface(1);				UsbEndpoint readEP = intf.getEndpoint(0);				UsbEndpoint writeEP = intf.getEndpoint(1);				UsbDeviceConnection connection = null;				while (!manager.hasPermission(myDev)){}				if (manager.hasPermission(myDev)) {					connection = manager.openDevice(myDev);				} 				connection.claimInterface(intf, true);				int tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				byte[] BBBMac = Arrays.copyOfRange(Arrays.copyOfRange(buffer, 						RNDISSize, RNDISSize + ETHSize),6,12);								UDP udpAnswer = new UDP(BOOTPS, BOOTPC, (short)BOOTPSize);				IPv4 ipAnswer = new IPv4((short) (udpAnswer.getLen() + (short)IPSize), (short)0, 													protocolUDP, AndroidIP, BBBIP);				Ether2 etherAnswer = new Ether2(BBBMac, AndroidMac, ethIP);				RNDIS rndisAnswer = new RNDIS(ETHSize + IPSize + UDPSize + BOOTPSize);				ByteMaker send = new ByteMaker();				ARP arpAnswer = new ARP((short)2, AndroidMac, AndroidIP, BBBMac, BBBIP);				etherAnswer.setH_proto(ethARP);				rndisAnswer.updateRNDIS(ETHSize+ARPSize);								byte[] output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), arpAnswer.getByteArray());				tmp = connection.bulkTransfer(writeEP, output, output.length, 10);				tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				while (tmp < 0) tmp = connection.bulkTransfer(readEP, buffer, 450, 10);				byte[] udp = Arrays.copyOfRange(buffer, RNDISSize +ETHSize + IPSize, RNDISSize +ETHSize + IPSize + UDPSize);				byte[] dstPort = Arrays.copyOfRange(udp, 0, 2);				byte[] srcPort = Arrays.copyOfRange(udp, 2, 4);				short sPort = ByteBuffer.wrap(srcPort).getShort();				short dPort = ByteBuffer.wrap(dstPort).getShort();								try {					File myFile = new File(Environment.getExternalStorageDirectory().getPath() + "/BBB/maker.itb");					FileInputStream fIn = new FileInputStream(myFile);					byte[] temporary = new byte[512];					int block = 1;					int count = fIn.read(temporary, 0, 512);					while(count != -1) {						TFTP tftpAnswer = new TFTP((short)3, (short)block);						udpAnswer = new UDP(sPort, dPort, (short) (TFTPSize + count));						ipAnswer = new IPv4((short) (udpAnswer.getLen() + (short)IPSize), (short)0, protocolUDP, AndroidIP, BBBIP);						etherAnswer = new Ether2(BBBMac, AndroidMac, ethIP);						rndisAnswer = new RNDIS(ETHSize + IPSize + UDPSize + TFTPSize + count);						tftpAnswer.setBlk_numer((short)block);												output = send.converter(rndisAnswer.getByteArray(), etherAnswer.getByteArray(), 												ipAnswer.getByteArray(), udpAnswer.getByteArray(), 												tftpAnswer.getByteArray(), temporary);												byte[] result = send.stripSize(output, RNDISSize + ETHSize + IPSize + UDPSize + TFTPSize + count);						tmp = connection.bulkTransfer(writeEP, result, result.length, 200);						buffer = new byte[450];						tmp = connection.bulkTransfer(readEP, buffer, 450, 200);						temporary = new byte[512];						block++;						count = fIn.read(temporary, 0, 512);					}					fIn.close();				} catch (Exception e) {					Log.d(TAG, e.getMessage());					return;				}				connection.close();			}		}).start();	}	public void debugDevice(UsbDevice device) {	        Log.i(TAG,"Model: " + device.getDeviceName());	        Log.i(TAG,"ID: " + device.getDeviceId());	        Log.i(TAG,"Class: " + device.getDeviceClass());	        Log.i(TAG,"Protocol: " + device.getDeviceProtocol());	        Log.i(TAG,"Vendor ID " + device.getVendorId());	        Log.i(TAG,"Product ID: " + device.getProductId());	        Log.i(TAG,"Interface count: " + device.getInterfaceCount());	        Log.i(TAG,"---------------------------------------");	   // Get interface details	        for (int index = 0; index < device.getInterfaceCount(); index++)	        {	        UsbInterface mUsbInterface = device.getInterface(index);	        Log.i(TAG,"  *****     *****");	        Log.i(TAG,"  Interface index: " + index);	        Log.i(TAG,"  Interface ID: " + mUsbInterface.getId());	        Log.i(TAG,"  Inteface class: " + mUsbInterface.getInterfaceClass());	        Log.i(TAG,"  Interface protocol: " + mUsbInterface.getInterfaceProtocol());	        Log.i(TAG,"  Endpoint count: " + mUsbInterface.getEndpointCount());	    // Get endpoint details 	            for (int epi = 0; epi < mUsbInterface.getEndpointCount(); epi++)	        {	            UsbEndpoint mEndpoint = mUsbInterface.getEndpoint(epi);	            Log.i(TAG,"    ++++   ++++   ++++");	            Log.i(TAG,"    Endpoint index: " + epi);	            Log.i(TAG,"    Attributes: " + mEndpoint.getAttributes());	            Log.i(TAG,"    Direction: " + mEndpoint.getDirection());	            Log.i(TAG,"    Number: " + mEndpoint.getEndpointNumber());	            Log.i(TAG,"    Interval: " + mEndpoint.getInterval());	            Log.i(TAG,"    Packet size: " + mEndpoint.getMaxPacketSize());	            Log.i(TAG,"    Type: " + mEndpoint.getType());	            }	       }	}	public void runWrite(final String fileName) {		new Thread(new Runnable() {			public void run() {				UsbDevice myDev = null;				UsbManager manager = (UsbManager) getSystemService(Context.USB_SERVICE);				HashMap<String, UsbDevice> deviceList = manager.getDeviceList();				Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();				while (deviceIterator.hasNext()) {					UsbDevice dev = deviceIterator.next();					if (dev.getProductId() == 42151 && dev.getVendorId() == 1317)						myDev = dev;				}				if (myDev == null) {					Log.d(TAG, "nothing!");					return;				}				UsbInterface intf = myDev.getInterface(1);				UsbEndpoint writeEP = intf.getEndpoint(1);				UsbEndpoint readEP = intf.getEndpoint(0);				UsbDeviceConnection connection = null;				while (!manager.hasPermission(myDev)){}				if (manager.hasPermission(myDev)) {					connection = manager.openDevice(myDev);				} 				if (connection == null) {					Log.d(TAG, "conn null");					return;				}				try {					connection.claimInterface(intf, true);				}				catch (Exception e) {					Log.d(TAG, e.getMessage());					return;				}				int tmp;				try {					CheckBox sdCard = (CheckBox)findViewById(R.id.checkBox1);					if (sdCard.isChecked()) {						byte makeSD[] = {(byte)'y',(byte)'s', (byte)'d'};						tmp = -1;						while(tmp<0) tmp = connection.bulkTransfer(writeEP, makeSD, makeSD.length, 10);					}					else {						byte makeSD[] = {(byte)'n', (byte)'s', (byte)'d'};						tmp = -1;						while(tmp<0) tmp = connection.bulkTransfer(writeEP, makeSD, makeSD.length, 10);					}					File myFile = new File(Environment.getExternalStorageDirectory().getPath() + "/BBB/" + fileName);					FileInputStream fIn = new FileInputStream(myFile);					byte[] name = myFile.getName().getBytes();					tmp = -1;					while(tmp<0) tmp = connection.bulkTransfer(writeEP, name, name.length, 10);					byte[] size = ByteBuffer.allocate(8).putLong(myFile.length()).array();					tmp = -1;					while(tmp < 0) tmp = connection.bulkTransfer(writeEP, size, size.length, 10);					byte[] temporary = new byte[1024];					int count = fIn.read(temporary, 0, 1024);					byte[] reader = new byte[10];					tmp = connection.bulkTransfer(readEP, reader, 5, 200);					while (tmp < 0) tmp = connection.bulkTransfer(readEP, reader, 5, 10);					while(count != -1) {						int tmP = connection.bulkTransfer(writeEP, temporary, count, 0);						while(tmP < 0) tmP = connection.bulkTransfer(writeEP, temporary, count, 10);						tmp = connection.bulkTransfer(readEP, reader, 3, 0);						while (tmp < 0) tmp = connection.bulkTransfer(readEP, reader, 3, 10);						if (tmP >0) soFar += tmP;						temporary = new byte[1024];						count = fIn.read(temporary, 0, 1024);					}					SystemClock.sleep(2000);					tmp = -1;					while(tmp < 0) tmp = connection.bulkTransfer(writeEP, END, 3, 10);					fIn.close();					soFar = 0;					runOnUiThread(new Runnable() {					    public void run() {							Context context = getApplicationContext();							CharSequence text = "Done sending image!";							int duration = Toast.LENGTH_LONG;							Toast toast = Toast.makeText(context, text, duration);							toast.show();					    }					});				} catch (Exception e) {					Log.d(TAG, e.getMessage());					return;				}			}		}).start();	}		public long downloadFile(String url, String title, String description, String fileName) {		DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));		request.setDescription(description);		request.setTitle(title);		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {		    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);		}		request.setDestinationInExternalPublicDir("BBB/", fileName);		DownloadManager manager = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);		return manager.enqueue(request);	}	public static String convertStreamToString(InputStream is) throws Exception {	    BufferedReader reader = new BufferedReader(new InputStreamReader(is));	    StringBuilder sb = new StringBuilder();	    String line = null;	    while ((line = reader.readLine()) != null) {	        sb.append(line);	    }	    is.close();	    return sb.toString();	}	private boolean isNetworkConnected() {		  ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);		  NetworkInfo ni = cm.getActiveNetworkInfo();		  if (ni == null) {		   return false;		  } else		   return true;		 }		public void downloadImage(String item) throws Exception {		if (isNetworkConnected()) {			if (item.equals("rPI-NOOBS_v1_2")) {			Log.d(TAG, "NOOBS_v1_2");			downloadFile("http://raspberry.mythic-beasts.com/raspberry/images/NOOBS/NOOBS_v1_2_1/NOOBS_v1_2_1.zip", 					"NOOBS_v1_2", "rPI", "NOOBS_v1_2_1.zip");			downloadedFile = "NOOBS_v1_2_1.zip";			}		else if (item.equals("rPI-Raspbian “wheezy”")) {			Log.d(TAG, "Raspbian “wheezy”");			downloadFile("hhttp://raspberry.mythic-beasts.com/raspberry/images/raspbian/2013-07-26-wheezy-raspbian/2013-07-26-wheezy-raspbian.zip", 					item, "rPI", "2013-07-26-wheezy-raspbian.zip");			downloadedFile = "2013-07-26-wheezy-raspbian.zip";			}		else if (item.equals("rPI-Soft-float Debian “wheezy”")) {			Log.d(TAG, "Soft-float Debian “wheezy”");			downloadFile("http://raspberry.mythic-beasts.com/raspberry/images/debian/7/2013-05-29-wheezy-armel/2013-05-29-wheezy-armel.zip",					item, "rPI", "2013-05-29-wheezy-armel.zip");			downloadedFile = "2013-05-29-wheezy-armel.zip";			}		else if (item.equals("rPI-Pidora")) {			Log.d(TAG, "Pidora");			downloadFile("http://raspberry.mythic-beasts.com/raspberry/images/pidora/pidora-18-r1c/pidora-18-r1c.zip",					item, "rPI", "pidora-18-r1c.zip");			downloadedFile = "pidora-18-r1c.zip";			}		else if (item.equals("rPI-Arch Linux ARM")) {			Log.d(TAG, "Arch Linux ARM");			downloadFile("http://raspberry.mythic-beasts.com/raspberry/images/archlinuxarm/archlinux-hf-2013-07-22/archlinux-hf-2013-07-22.img.zip",					item, "rPI", "archlinux-hf-2013-07-22.img.zip");			downloadedFile = "archlinux-hf-2013-07-22.img.zip";			}		else if (item.equals("rPI-RISC OS")) {			Log.d(TAG, "RISC OS");			downloadFile("http://raspberry.mythic-beasts.com/raspberry/images/riscos/riscos-2013-07-10-RC11/riscos-2013-07-10-RC11.zip",					item, "rPI", "riscos-2013-07-10-RC11.zip");			downloadedFile = "riscos-2013-07-10-RC11.zip";			}		else if (item.equals("BBB-Angstrom")) {			downloadAngstrom();		}		}		else {			runOnUiThread(new Runnable() {			    public void run() {					Context context = getApplicationContext();					CharSequence text = "No internet connection!";					int duration = Toast.LENGTH_LONG;					Toast toast = Toast.makeText(context, text, duration);					toast.show();			    }			});		}	}	public void downloadAngstrom() throws Exception {		if(isNetworkConnected())			try {			URL input = new URL("http://beagleboard.org/latest-images");			URLConnection conn = input.openConnection();			int contentLength = conn.getContentLength();			DataInputStream stream = new DataInputStream(input.openStream());			byte[] buffer = new byte[contentLength];			stream.readFully(buffer);			stream.close();			DataOutputStream output = new DataOutputStream(new FileOutputStream(Environment.getExternalStorageDirectory() + "/BBB/page.html"));			output.write(buffer);			output.flush();			output.close();			File fl = new File(Environment.getExternalStorageDirectory() + "/BBB/page.html");		    FileInputStream fin = new FileInputStream(fl);		    StringBuffer fileContent = new StringBuffer("");		    byte[] buff = new byte[12288];		    while (fin.read(buff) != -1) {		        fileContent.append(new String(buff));		    }		    int start = fileContent.toString().indexOf("https://s3.");		    int end = fileContent.toString().indexOf(".img.xz");		    Log.d(TAG, fileContent.toString().substring(start, end+7));		    fin.close();        		    String filename = fileContent.toString().substring(start, end+7);		    downloadFile(fileContent.toString().substring(start, end+7),		    		"Angstrom", filename, "flash.img.xz");		    downloadedFile = "flash.img.xz";		    } catch(FileNotFoundException e) {			return;			} catch (IOException e) {			return;			}		else {			runOnUiThread(new Runnable() {			    public void run() {					Context context = getApplicationContext();					CharSequence text = "No internet connection!";					int duration = Toast.LENGTH_LONG;					Toast toast = Toast.makeText(context, text, duration);					toast.show();			    }			});		}	}	ArrayAdapter<String> setupSpinner() {		List<String> list = new ArrayList<String>();		list.add("BBB-Angstrom");    	list.add("rPI-NOOBS_v1_2");    	list.add("rPI-Raspbian “wheezy”");    	list.add("rPI-Soft-float Debian “wheezy”");    	list.add("rPI-Pidora");    	list.add("rPI-Arch Linux ARM");    	list.add("rPI-RISC OS");    	ArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this,    		android.R.layout.simple_spinner_item, list);    	dataAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);    	return dataAdapter;	}	}